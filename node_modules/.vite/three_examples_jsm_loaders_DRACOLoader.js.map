{
  "version": 3,
  "sources": ["../three/examples/jsm/loaders/DRACOLoader.js"],
  "sourcesContent": ["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFileLoader,\n\tLoader\n} from 'three';\n\nconst _taskCache = new WeakMap();\n\nclass DRACOLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.decoderPath = '';\n\t\tthis.decoderConfig = {};\n\t\tthis.decoderBinary = null;\n\t\tthis.decoderPending = null;\n\n\t\tthis.workerLimit = 4;\n\t\tthis.workerPool = [];\n\t\tthis.workerNextTaskID = 1;\n\t\tthis.workerSourceURL = '';\n\n\t\tthis.defaultAttributeIDs = {\n\t\t\tposition: 'POSITION',\n\t\t\tnormal: 'NORMAL',\n\t\t\tcolor: 'COLOR',\n\t\t\tuv: 'TEX_COORD'\n\t\t};\n\t\tthis.defaultAttributeTypes = {\n\t\t\tposition: 'Float32Array',\n\t\t\tnormal: 'Float32Array',\n\t\t\tcolor: 'Float32Array',\n\t\t\tuv: 'Float32Array'\n\t\t};\n\n\t}\n\n\tsetDecoderPath( path ) {\n\n\t\tthis.decoderPath = path;\n\n\t\treturn this;\n\n\t}\n\n\tsetDecoderConfig( config ) {\n\n\t\tthis.decoderConfig = config;\n\n\t\treturn this;\n\n\t}\n\n\tsetWorkerLimit( workerLimit ) {\n\n\t\tthis.workerLimit = workerLimit;\n\n\t\treturn this;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst loader = new FileLoader( this.manager );\n\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, ( buffer ) => {\n\n\t\t\tconst taskConfig = {\n\t\t\t\tattributeIDs: this.defaultAttributeIDs,\n\t\t\t\tattributeTypes: this.defaultAttributeTypes,\n\t\t\t\tuseUniqueIDs: false\n\t\t\t};\n\n\t\t\tthis.decodeGeometry( buffer, taskConfig )\n\t\t\t\t.then( onLoad )\n\t\t\t\t.catch( onError );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n\tdecodeDracoFile( buffer, callback, attributeIDs, attributeTypes ) {\n\n\t\tconst taskConfig = {\n\t\t\tattributeIDs: attributeIDs || this.defaultAttributeIDs,\n\t\t\tattributeTypes: attributeTypes || this.defaultAttributeTypes,\n\t\t\tuseUniqueIDs: !! attributeIDs\n\t\t};\n\n\t\tthis.decodeGeometry( buffer, taskConfig ).then( callback );\n\n\t}\n\n\tdecodeGeometry( buffer, taskConfig ) {\n\n\t\t// TODO: For backward-compatibility, support 'attributeTypes' objects containing\n\t\t// references (rather than names) to typed array constructors. These must be\n\t\t// serialized before sending them to the worker.\n\t\tfor ( const attribute in taskConfig.attributeTypes ) {\n\n\t\t\tconst type = taskConfig.attributeTypes[ attribute ];\n\n\t\t\tif ( type.BYTES_PER_ELEMENT !== undefined ) {\n\n\t\t\t\ttaskConfig.attributeTypes[ attribute ] = type.name;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst taskKey = JSON.stringify( taskConfig );\n\n\t\t// Check for an existing task using this buffer. A transferred buffer cannot be transferred\n\t\t// again from this thread.\n\t\tif ( _taskCache.has( buffer ) ) {\n\n\t\t\tconst cachedTask = _taskCache.get( buffer );\n\n\t\t\tif ( cachedTask.key === taskKey ) {\n\n\t\t\t\treturn cachedTask.promise;\n\n\t\t\t} else if ( buffer.byteLength === 0 ) {\n\n\t\t\t\t// Technically, it would be possible to wait for the previous task to complete,\n\t\t\t\t// transfer the buffer back, and decode again with the second configuration. That\n\t\t\t\t// is complex, and I don't know of any reason to decode a Draco buffer twice in\n\t\t\t\t// different ways, so this is left unimplemented.\n\t\t\t\tthrow new Error(\n\n\t\t\t\t\t'THREE.DRACOLoader: Unable to re-decode a buffer with different ' +\n\t\t\t\t\t'settings. Buffer has already been transferred.'\n\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tlet worker;\n\t\tconst taskID = this.workerNextTaskID ++;\n\t\tconst taskCost = buffer.byteLength;\n\n\t\t// Obtain a worker and assign a task, and construct a geometry instance\n\t\t// when the task completes.\n\t\tconst geometryPending = this._getWorker( taskID, taskCost )\n\t\t\t.then( ( _worker ) => {\n\n\t\t\t\tworker = _worker;\n\n\t\t\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\t\t\tworker._callbacks[ taskID ] = { resolve, reject };\n\n\t\t\t\t\tworker.postMessage( { type: 'decode', id: taskID, taskConfig, buffer }, [ buffer ] );\n\n\t\t\t\t\t// this.debug();\n\n\t\t\t\t} );\n\n\t\t\t} )\n\t\t\t.then( ( message ) => this._createGeometry( message.geometry ) );\n\n\t\t// Remove task from the task list.\n\t\t// Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n\t\tgeometryPending\n\t\t\t.catch( () => true )\n\t\t\t.then( () => {\n\n\t\t\t\tif ( worker && taskID ) {\n\n\t\t\t\t\tthis._releaseTask( worker, taskID );\n\n\t\t\t\t\t// this.debug();\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t// Cache the task result.\n\t\t_taskCache.set( buffer, {\n\n\t\t\tkey: taskKey,\n\t\t\tpromise: geometryPending\n\n\t\t} );\n\n\t\treturn geometryPending;\n\n\t}\n\n\t_createGeometry( geometryData ) {\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tif ( geometryData.index ) {\n\n\t\t\tgeometry.setIndex( new BufferAttribute( geometryData.index.array, 1 ) );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < geometryData.attributes.length; i ++ ) {\n\n\t\t\tconst attribute = geometryData.attributes[ i ];\n\t\t\tconst name = attribute.name;\n\t\t\tconst array = attribute.array;\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tgeometry.setAttribute( name, new BufferAttribute( array, itemSize ) );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n\t_loadLibrary( url, responseType ) {\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.decoderPath );\n\t\tloader.setResponseType( responseType );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\tloader.load( url, resolve, undefined, reject );\n\n\t\t} );\n\n\t}\n\n\tpreload() {\n\n\t\tthis._initDecoder();\n\n\t\treturn this;\n\n\t}\n\n\t_initDecoder() {\n\n\t\tif ( this.decoderPending ) return this.decoderPending;\n\n\t\tconst useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';\n\t\tconst librariesPending = [];\n\n\t\tif ( useJS ) {\n\n\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_decoder.js', 'text' ) );\n\n\t\t} else {\n\n\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_wasm_wrapper.js', 'text' ) );\n\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_decoder.wasm', 'arraybuffer' ) );\n\n\t\t}\n\n\t\tthis.decoderPending = Promise.all( librariesPending )\n\t\t\t.then( ( libraries ) => {\n\n\t\t\t\tconst jsContent = libraries[ 0 ];\n\n\t\t\t\tif ( ! useJS ) {\n\n\t\t\t\t\tthis.decoderConfig.wasmBinary = libraries[ 1 ];\n\n\t\t\t\t}\n\n\t\t\t\tconst fn = DRACOWorker.toString();\n\n\t\t\t\tconst body = [\n\t\t\t\t\t'/* draco decoder */',\n\t\t\t\t\tjsContent,\n\t\t\t\t\t'',\n\t\t\t\t\t'/* worker */',\n\t\t\t\t\tfn.substring( fn.indexOf( '{' ) + 1, fn.lastIndexOf( '}' ) )\n\t\t\t\t].join( '\\n' );\n\n\t\t\t\tthis.workerSourceURL = URL.createObjectURL( new Blob( [ body ] ) );\n\n\t\t\t} );\n\n\t\treturn this.decoderPending;\n\n\t}\n\n\t_getWorker( taskID, taskCost ) {\n\n\t\treturn this._initDecoder().then( () => {\n\n\t\t\tif ( this.workerPool.length < this.workerLimit ) {\n\n\t\t\t\tconst worker = new Worker( this.workerSourceURL );\n\n\t\t\t\tworker._callbacks = {};\n\t\t\t\tworker._taskCosts = {};\n\t\t\t\tworker._taskLoad = 0;\n\n\t\t\t\tworker.postMessage( { type: 'init', decoderConfig: this.decoderConfig } );\n\n\t\t\t\tworker.onmessage = function ( e ) {\n\n\t\t\t\t\tconst message = e.data;\n\n\t\t\t\t\tswitch ( message.type ) {\n\n\t\t\t\t\t\tcase 'decode':\n\t\t\t\t\t\t\tworker._callbacks[ message.id ].resolve( message );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'error':\n\t\t\t\t\t\t\tworker._callbacks[ message.id ].reject( message );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"' );\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tthis.workerPool.push( worker );\n\n\t\t\t} else {\n\n\t\t\t\tthis.workerPool.sort( function ( a, b ) {\n\n\t\t\t\t\treturn a._taskLoad > b._taskLoad ? - 1 : 1;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tconst worker = this.workerPool[ this.workerPool.length - 1 ];\n\t\t\tworker._taskCosts[ taskID ] = taskCost;\n\t\t\tworker._taskLoad += taskCost;\n\t\t\treturn worker;\n\n\t\t} );\n\n\t}\n\n\t_releaseTask( worker, taskID ) {\n\n\t\tworker._taskLoad -= worker._taskCosts[ taskID ];\n\t\tdelete worker._callbacks[ taskID ];\n\t\tdelete worker._taskCosts[ taskID ];\n\n\t}\n\n\tdebug() {\n\n\t\tconsole.log( 'Task load: ', this.workerPool.map( ( worker ) => worker._taskLoad ) );\n\n\t}\n\n\tdispose() {\n\n\t\tfor ( let i = 0; i < this.workerPool.length; ++ i ) {\n\n\t\t\tthis.workerPool[ i ].terminate();\n\n\t\t}\n\n\t\tthis.workerPool.length = 0;\n\n\t\treturn this;\n\n\t}\n\n}\n\n/* WEB WORKER */\n\nfunction DRACOWorker() {\n\n\tlet decoderConfig;\n\tlet decoderPending;\n\n\tonmessage = function ( e ) {\n\n\t\tconst message = e.data;\n\n\t\tswitch ( message.type ) {\n\n\t\t\tcase 'init':\n\t\t\t\tdecoderConfig = message.decoderConfig;\n\t\t\t\tdecoderPending = new Promise( function ( resolve/*, reject*/ ) {\n\n\t\t\t\t\tdecoderConfig.onModuleLoaded = function ( draco ) {\n\n\t\t\t\t\t\t// Module is Promise-like. Wrap before resolving to avoid loop.\n\t\t\t\t\t\tresolve( { draco: draco } );\n\n\t\t\t\t\t};\n\n\t\t\t\t\tDracoDecoderModule( decoderConfig ); // eslint-disable-line no-undef\n\n\t\t\t\t} );\n\t\t\t\tbreak;\n\n\t\t\tcase 'decode':\n\t\t\t\tconst buffer = message.buffer;\n\t\t\t\tconst taskConfig = message.taskConfig;\n\t\t\t\tdecoderPending.then( ( module ) => {\n\n\t\t\t\t\tconst draco = module.draco;\n\t\t\t\t\tconst decoder = new draco.Decoder();\n\t\t\t\t\tconst decoderBuffer = new draco.DecoderBuffer();\n\t\t\t\t\tdecoderBuffer.Init( new Int8Array( buffer ), buffer.byteLength );\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tconst geometry = decodeGeometry( draco, decoder, decoderBuffer, taskConfig );\n\n\t\t\t\t\t\tconst buffers = geometry.attributes.map( ( attr ) => attr.array.buffer );\n\n\t\t\t\t\t\tif ( geometry.index ) buffers.push( geometry.index.array.buffer );\n\n\t\t\t\t\t\tself.postMessage( { type: 'decode', id: message.id, geometry }, buffers );\n\n\t\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\t\tconsole.error( error );\n\n\t\t\t\t\t\tself.postMessage( { type: 'error', id: message.id, error: error.message } );\n\n\t\t\t\t\t} finally {\n\n\t\t\t\t\t\tdraco.destroy( decoderBuffer );\n\t\t\t\t\t\tdraco.destroy( decoder );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t};\n\n\tfunction decodeGeometry( draco, decoder, decoderBuffer, taskConfig ) {\n\n\t\tconst attributeIDs = taskConfig.attributeIDs;\n\t\tconst attributeTypes = taskConfig.attributeTypes;\n\n\t\tlet dracoGeometry;\n\t\tlet decodingStatus;\n\n\t\tconst geometryType = decoder.GetEncodedGeometryType( decoderBuffer );\n\n\t\tif ( geometryType === draco.TRIANGULAR_MESH ) {\n\n\t\t\tdracoGeometry = new draco.Mesh();\n\t\t\tdecodingStatus = decoder.DecodeBufferToMesh( decoderBuffer, dracoGeometry );\n\n\t\t} else if ( geometryType === draco.POINT_CLOUD ) {\n\n\t\t\tdracoGeometry = new draco.PointCloud();\n\t\t\tdecodingStatus = decoder.DecodeBufferToPointCloud( decoderBuffer, dracoGeometry );\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.DRACOLoader: Unexpected geometry type.' );\n\n\t\t}\n\n\t\tif ( ! decodingStatus.ok() || dracoGeometry.ptr === 0 ) {\n\n\t\t\tthrow new Error( 'THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg() );\n\n\t\t}\n\n\t\tconst geometry = { index: null, attributes: [] };\n\n\t\t// Gather all vertex attributes.\n\t\tfor ( const attributeName in attributeIDs ) {\n\n\t\t\tconst attributeType = self[ attributeTypes[ attributeName ] ];\n\n\t\t\tlet attribute;\n\t\t\tlet attributeID;\n\n\t\t\t// A Draco file may be created with default vertex attributes, whose attribute IDs\n\t\t\t// are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n\t\t\t// a Draco file may contain a custom set of attributes, identified by known unique\n\t\t\t// IDs. glTF files always do the latter, and `.drc` files typically do the former.\n\t\t\tif ( taskConfig.useUniqueIDs ) {\n\n\t\t\t\tattributeID = attributeIDs[ attributeName ];\n\t\t\t\tattribute = decoder.GetAttributeByUniqueId( dracoGeometry, attributeID );\n\n\t\t\t} else {\n\n\t\t\t\tattributeID = decoder.GetAttributeId( dracoGeometry, draco[ attributeIDs[ attributeName ] ] );\n\n\t\t\t\tif ( attributeID === - 1 ) continue;\n\n\t\t\t\tattribute = decoder.GetAttribute( dracoGeometry, attributeID );\n\n\t\t\t}\n\n\t\t\tgeometry.attributes.push( decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) );\n\n\t\t}\n\n\t\t// Add index.\n\t\tif ( geometryType === draco.TRIANGULAR_MESH ) {\n\n\t\t\tgeometry.index = decodeIndex( draco, decoder, dracoGeometry );\n\n\t\t}\n\n\t\tdraco.destroy( dracoGeometry );\n\n\t\treturn geometry;\n\n\t}\n\n\tfunction decodeIndex( draco, decoder, dracoGeometry ) {\n\n\t\tconst numFaces = dracoGeometry.num_faces();\n\t\tconst numIndices = numFaces * 3;\n\t\tconst byteLength = numIndices * 4;\n\n\t\tconst ptr = draco._malloc( byteLength );\n\t\tdecoder.GetTrianglesUInt32Array( dracoGeometry, byteLength, ptr );\n\t\tconst index = new Uint32Array( draco.HEAPF32.buffer, ptr, numIndices ).slice();\n\t\tdraco._free( ptr );\n\n\t\treturn { array: index, itemSize: 1 };\n\n\t}\n\n\tfunction decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) {\n\n\t\tconst numComponents = attribute.num_components();\n\t\tconst numPoints = dracoGeometry.num_points();\n\t\tconst numValues = numPoints * numComponents;\n\t\tconst byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n\t\tconst dataType = getDracoDataType( draco, attributeType );\n\n\t\tconst ptr = draco._malloc( byteLength );\n\t\tdecoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, dataType, byteLength, ptr );\n\t\tconst array = new attributeType( draco.HEAPF32.buffer, ptr, numValues ).slice();\n\t\tdraco._free( ptr );\n\n\t\treturn {\n\t\t\tname: attributeName,\n\t\t\tarray: array,\n\t\t\titemSize: numComponents\n\t\t};\n\n\t}\n\n\tfunction getDracoDataType( draco, attributeType ) {\n\n\t\tswitch ( attributeType ) {\n\n\t\t\tcase Float32Array: return draco.DT_FLOAT32;\n\t\t\tcase Int8Array: return draco.DT_INT8;\n\t\t\tcase Int16Array: return draco.DT_INT16;\n\t\t\tcase Int32Array: return draco.DT_INT32;\n\t\t\tcase Uint8Array: return draco.DT_UINT8;\n\t\t\tcase Uint16Array: return draco.DT_UINT16;\n\t\t\tcase Uint32Array: return draco.DT_UINT32;\n\n\t\t}\n\n\t}\n\n}\n\nexport { DRACOLoader };\n"],
  "mappings": "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",
  "names": []
}
